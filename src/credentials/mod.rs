//! Allows to specify credentials for URLs generated by [`crate::Map`].
//!
//! Credentials can be of 2 types:
//!   - [`Credentials::ApiKey`] (API Key based authentication) and
//!   - [`Credentials::ClientId`] (Client ID based authentication).
//!
//! The easiest and the most common way to create credentials id from an API key and by using
//! the `into()` operator:
//!
//! ```rust
//! # use gmaps_static::*;
//! let credentials: Credentials = "YOUR_API_KEY".into();
//! ```
//!
//! Other helper functions are available to simplify the creation of credentials:
//!
//!  - [`Credentials::with_api_key`]
//!  - [`Credentials::with_secret_key`]
//!  - [`Credentials::with_client`]
//!  - [`Credentials::try_from_default_env`]
//!  - [`Credentials::try_from_env`]
//!
//! When using credentials with a secret, all the generated URLs will be automatically signed.
//! Check the [`sign`] function for more details.

use ring::hmac;
use std::env;
use url::Url;

lazy_static! {
    static ref BASE64_URL_SAFE: base64::Config =
        base64::Config::new(base64::CharacterSet::UrlSafe, true);
}

fn decode_secret(secret_b64: &str) -> Result<Vec<u8>, String> {
    base64::decode_config(secret_b64, *BASE64_URL_SAFE)
        .map_err(|e| format!("Failed to decode signature as Base64 string: {}", e))
}

/// Signs a URL using [Google Static Map API signature algorithm](https://developers.google.com/maps/documentation/maps-static/get-api-key#dig-sig-manual).
///
/// You don't have to use this function directly. When creating URLs using [`crate::Map`], if [`crate::Credentials`] with
/// a secret are passed, this function will be automatically invoked to sign the generated URL.
pub fn sign(url: &Url, key_bytes: Vec<u8>) -> String {
    let key = hmac::Key::new(hmac::HMAC_SHA1_FOR_LEGACY_USE_ONLY, &key_bytes);

    let message = format!("{}?{}", url.path(), url.query().unwrap());
    let signature = hmac::sign(&key, message.as_bytes());

    let encoded_signature = base64::encode_config(signature.as_ref(), *BASE64_URL_SAFE);

    encoded_signature
}

/// Credentials (API Key or Client ID) with a secret
#[derive(Clone)]
pub enum Credentials {
    /// Credentials based on API key and an optional secret
    ApiKey(String, Option<Vec<u8>>),
    /// Credentials based on a Client ID and a secret
    ClientId(String, Vec<u8>),
}

impl Credentials {
    #[doc(hidden)]
    pub fn get_key_name(&self) -> String {
        String::from(match self {
            Credentials::ApiKey(_, _) => "key",
            Credentials::ClientId(_, _) => "client",
        })
    }

    #[doc(hidden)]
    pub fn get_key(&self) -> String {
        match &self {
            Credentials::ApiKey(api_key, _) => api_key.clone(),
            Credentials::ClientId(client_id, _) => client_id.clone(),
        }
    }

    #[doc(hidden)]
    pub fn get_secret(&self) -> Option<Vec<u8>> {
        match &self {
            Credentials::ApiKey(_, maybe_secret) => maybe_secret.clone(),
            Credentials::ClientId(_, secret) => Some(secret.clone()),
        }
    }

    /// Creates credentials from an API key
    pub fn with_api_key<S: AsRef<str>>(api_key: S) -> Credentials {
        Credentials::ApiKey(String::from(api_key.as_ref()), None)
    }

    fn with_api_key_and_maybe_secret<S: AsRef<str>>(
        api_key: S,
        secret: Option<S>,
    ) -> Result<Credentials, String> {
        let secret = match secret {
            Some(secret_b64) => Some(decode_secret(secret_b64.as_ref())?),
            None => None,
        };
        Ok(Credentials::ApiKey(String::from(api_key.as_ref()), secret))
    }

    /// Creates credentials from an API key and a secret
    pub fn with_secret_key<S: AsRef<str>>(api_key: S, secret: S) -> Result<Credentials, String> {
        let secret = decode_secret(secret.as_ref())?;

        Ok(Credentials::ApiKey(
            String::from(api_key.as_ref()),
            Some(secret),
        ))
    }

    /// Creates credentials from a Client ID and a secret
    pub fn with_client<S: AsRef<str>>(client_id: S, secret: S) -> Result<Credentials, String> {
        let secret = decode_secret(secret.as_ref())?;

        Ok(Credentials::ClientId(
            String::from(client_id.as_ref()),
            secret,
        ))
    }

    /// Tries to create credentials from environment variables.
    ///
    /// You have to specify the name of the environment variables where the values will be looked for.
    ///
    /// This function will create Client ID based credentials if the environment vairiable with the name provided in
    /// `client_id_var_name` is set, otherwise it will try to create API key based credentials looking for the
    /// API Key in the environment variable specified by `api_key_var_name`.
    pub fn try_from_env<S: AsRef<str>>(
        client_id_var_name: S,
        api_key_var_name: S,
        secret_key_var_name: S,
    ) -> Result<Credentials, String> {
        let client_id = env::var(client_id_var_name.as_ref());
        let api_key = env::var(api_key_var_name.as_ref());
        let secret_key = env::var(secret_key_var_name.as_ref());

        if client_id.is_err() && api_key.is_err() {
            return Err(format!(
                "Either '{}' or '{}' must be set as environment variables",
                client_id_var_name.as_ref(),
                api_key_var_name.as_ref()
            ));
        }

        if let Ok(client_id) = client_id {
            // Constructs an instance of ClientIdCredentials
            if secret_key.is_err() {
                return Err(format!(
                    "Secret key not found (expected in environmen variable '{}'). You need to provide a signature when providing a value for environment variable '{}'",
                    secret_key_var_name.as_ref(),
                    client_id_var_name.as_ref()
                ));
            }

            return Credentials::with_client(client_id, secret_key.unwrap());
        }

        // Constructs an instance of ApiKeyCredentials
        Credentials::with_api_key_and_maybe_secret(api_key.unwrap(), secret_key.ok())
    }

    /// It works Like [`Credentials::try_from_env`] but it uses default name for environment variables:
    ///
    ///  - `CLIENT_ID` for looking up the Client ID
    ///  - `API_KEY` for looking up the API key
    ///  - `SECRET_KEY` for looking up the secret
    pub fn try_from_default_env() -> Result<Credentials, String> {
        Self::try_from_env("CLIENT_ID", "API_KEY", "SECRET_KEY")
    }
}

impl<S: AsRef<str>> From<S> for Credentials {
    fn from(api_key: S) -> Self {
        Credentials::with_api_key(api_key)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use url::Url;

    #[test]
    fn it_signs_a_url() {
        let url = Url::parse(
            "https://maps.googleapis.com/maps/api/staticmap\
        ?center=Brooklyn+Bridge%2CNew+York%2CNY\
        &zoom=13\
        &size=600x300\
        &maptype=roadmap\
        &markers=color%3Ablue%7Clabel%3AS%7C40.702147%2C-74.015794\
        &markers=color%3Agreen%7Clabel%3AG%7C40.711614%2C-74.012318\
        &markers=color%3Ared%7Clabel%3AC%7C40.718217%2C-73.998284\
        &key=YOUR_API_KEY",
        )
        .unwrap();

        // secret_b64 = "X8XXXxxxxxXwrIEQfguOVNGv2jY=";
        let secret = vec![
            95, 197, 215, 95, 28, 113, 199, 21, 240, 172, 129, 16, 126, 11, 142, 84, 209, 175, 218,
            54,
        ];
        let signature = sign(&url, secret);
        let expected_signature = String::from("AlLkp3bubbkQNFc-upyF2jbylSs=");

        assert_eq!(signature, expected_signature);
    }
}
